!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).kaiEloRating={})}(this,(function(e){"use strict";function t(e){const t=(e.opponentRank-e.playerRank)/400;return 1/(1+Math.pow(10,t))}function a(e){const{actualScore:t,expectedScore:a,kFactor:r}=e;return r*(t-a)}function r(e){const{playerRank:r,playerKFactor:n,opponentRank:o,opponentKFactor:c,matchOutcome:l}=e,i=t({playerRank:r,opponentRank:o}),s=Math.round(a({actualScore:l,expectedScore:i,kFactor:n})),u=t({playerRank:o,opponentRank:r}),p=Math.round(a({actualScore:1-l,expectedScore:u,kFactor:c}));return{player:{initialRank:r,newRank:r+s,rankDiff:s},opponent:{initialRank:o,newRank:o+p,rankDiff:p}}}function n(e){const t=/^(\(|\[)(\d+|\d+.?\d+),(\d+|\d+.?\d+)(\)|\])$/g.exec(e);if(null===t)throw new Error(`range description invalid: ${e}`);const a=parseFloat(t[2]),r=parseFloat(t[3]);if(a>r)throw new Error(`range description invalid, lower bound is superior to upper bound: ${e}`);return[{lowerBoundValue:a,isIncluded:"("===t[1]},{upperBoundValue:r,isIncluded:")"===t[4]}]}const o={expectedScore:t,scoreDifferential:a,monoMatchCalculator:r,multiMatchCalculator:function(e){const{playerRank:r,playerKFactor:n,matchesSetup:o}=e;if(!Array.isArray(o)||0===o.length)throw new Error('multiMatchCalculator - no valid matches provided in "matchesSetup" property');const c=o.map((e=>t({playerRank:r,opponentRank:e.opponentRank}))).reduce(((e,t)=>e+t),0),l=o.reduce(((e,t)=>e+t.matchOutcome),0),i=Math.round(a({actualScore:l,expectedScore:c,kFactor:n}));return{initialRank:r,newRank:r+i,rankDiff:i}}},c=class extends class{_initialRank;_kFactorRule;constructor(e,t){this._initialRank=e,this._kFactorRule=t}get initialRank(){return this._initialRank}set initialRank(e){this._initialRank=e}get kFactorRule(){return this._kFactorRule}set kFactorRule(e){this._kFactorRule=e}}{_players=[];_matches=[];constructor(e,t){super(e,t)}_getPlayer(e){const t=this._players.find((t=>t.id===e));return t||null}createPlayer(e){const t=this._players.length,a=Object.assign({creationDate:Date.now(),lastPlayed:null,initialRank:this.initialRank,currentRank:this.initialRank,matches:[]},e,{id:t});return this._players.push(a),{...a}}deletePlayer(e){this._players=this._players.filter((t=>t.id!==e))}getPlayer(e){const t=this._players.find((t=>t.id===e));return t?{...t,matches:[...t.matches]}:null}getAllPlayers(){return this._players.map((e=>({...e})))}getAllMatches(){return this._matches.map((e=>({...e})))}getPlayerMatches(e){const t=this.getPlayer(e);if(!t)throw new Error(`EloRankingBoard/getPlayerMatches - can't find matches for player #${e}, player do not exist`);return this._matches.filter((e=>t?.matches.includes(e.id))).map((e=>({...e})))}getMatch(e){const t=this._matches.find((t=>t.id===e));return t?{...t}:null}createMatch(e){const t=Date.now(),a=this._matches.length;if(e.playerAId===e.playerBId)throw new Error(`EloRankingBoard/createMatch - same player for both sides of the match: playerA #${e.playerAId} = playerB #${e.playerBId}`);const n=this._getPlayer(e.playerAId),o=this._getPlayer(e.playerBId);if(!n||!o)throw new Error(`EloRankingBoard/createMatch - one or both players in a match can't be found: playerA #${e.playerAId} & playerB #${e.playerBId}`);const c=this.kFactorRule(n),l=this.kFactorRule(o),i=Object.assign({},e,{id:a,creationDate:t,resolutionDate:t,playerARank:n?.currentRank,playerBRank:o?.currentRank,playerAKFactor:c,playerBKFactor:l});this._matches.push(i);const s=r({playerRank:n?.currentRank,playerKFactor:c,opponentRank:o?.currentRank,opponentKFactor:l,matchOutcome:e.matchOutcome});return n.currentRank=s.player.newRank,n.matches.push(i.id),o.currentRank=s.opponent.newRank,o.matches.push(i.id),n.lastPlayed=o.lastPlayed=i.resolutionDate,{...i}}getMatchExpectancy(e,a){if(e===a)throw new Error(`EloRankingBoard/getMatchExpectancy - same player for both sides of the match: playerA #${e} = playerB #${a}`);const r=this.getPlayer(e),n=this.getPlayer(a);if(!r||!n)throw new Error(`EloRankingBoard/getMatchExpectancy - one or both players in a match can't be found: playerA #${e} & playerB #${a}`);return t({playerRank:r.currentRank,opponentRank:n.currentRank})}},l=function(e){return()=>e},i=function(e){const t=e.map((e=>({kFactorValue:e.kFactorValue,range:n(e.range)})));return a=>{const r=t.filter((e=>{const t=e.range[0].isIncluded,r=e.range[1].isIncluded,n=e.range[0].lowerBoundValue,o=e.range[1].upperBoundValue;return t&&r?n<=a.currentRank&&a.currentRank<=o:!t&&r?n<a.currentRank&&a.currentRank<=o:t&&!r?n<=a.currentRank&&a.currentRank<o:n<a.currentRank&&a.currentRank<o}));if(0===r.length)throw new Error(`no match found for provided stages: ${e} (player rank: ${a.currentRank})`);if(r.length>1)throw new Error(`multiple matches found for provided stages: ${e} (player rank: ${a.currentRank})`);return r[0].kFactorValue}};e.EloEngine=o,e.EloRankingBoardInMemory=c,e.adaptToPlayerRankKFactorRuleMaker=i,e.fixedKFactorRuleMaker=l}));
